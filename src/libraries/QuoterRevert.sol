// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {ParseBytes} from "@uniswap/v4-core/src/libraries/ParseBytes.sol";

library QuoterRevert {
    using QuoterRevert for bytes;
    using ParseBytes for bytes;

    /// @notice error thrown when invalid revert bytes are thrown by the quote
    error UnexpectedRevertBytes(bytes revertData);

    /// @notice error thrown containing the quote as the data, to be caught and parsed later
    error QuoteSwap(uint256 amount);

    /// @notice reverts, where the revert data is the provided bytes
    /// @dev called when quoting, at the end of simulating a swap, to revert with the swap information as the revert reason
    function revertQuote(uint256 amountUnspecified) internal pure {
        revert QuoteSwap(amountUnspecified);
    }

    /// @notice reverts, where the revert data is the provided bytes
    function bubbleReason(bytes memory revertData) internal pure {
        // mload(revertData): the length of the revert data
        // add(revertData, 0x20): a pointer to the start of the revert data
        assembly ("memory-safe") {
            revert(add(revertData, 0x20), mload(revertData))
        }
    }

    /// @notice check revert reasons are of the expected length; otherwise revert with different message
    /// @dev called after a swap simulation reverts, to check if the revert was valid encoded quote information, or an internal issue
    function validateRevertReason(bytes memory reason) internal pure {
        if (reason.parseSelector() != QuoteSwap.selector) {
            revert UnexpectedRevertBytes(reason);
        }
    }

    /// @notice validates a received revert reason from a swap.
    /// Then, if valid, decodes it into the information generated by a quote
    function parseReturnData(bytes memory reason) internal pure returns (uint256) {
        reason.validateRevertReason();
        return reason.parseAmountUnpecified();
    }

    /// @notice extracts the amountUnspecified from an encoded QuoteSwap(amountUnspecified)
    function parseAmountUnpecified(bytes memory reason) internal pure returns (uint256 amountUnspecified) {
        // reason -> reason+0x1f is the length of the reason string
        // reason+0x20 -> reason+0x23 is the selector of QuoteSwap
        // reason+0x24 -> reason+0x43 is the amountUnspecified
        assembly ("memory-safe") {
            amountUnspecified := mload(add(reason, 0x24))
        }
    }
}
