// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import {Currency, CurrencyLibrary} from "@uniswap/v4-core/src/types/Currency.sol";
import {IV4Router} from "../../src/interfaces/IV4Router.sol";
import {PermissionedRoutingTestHelpers} from "../shared/PermissionedRoutingTestHelpers.sol";
import {Planner} from "../shared/Planner.sol";
import {Actions} from "../../src/libraries/Actions.sol";
import {ActionConstants} from "../../src/libraries/ActionConstants.sol";
import {MockAllowList} from "../mocks/MockAllowList.sol";
import {IAllowlistChecker} from "../../src/hooks/permissionedPools/interfaces/IAllowlistChecker.sol";
import {WrappedPermissionedToken} from "../../src/hooks/permissionedPools/WrappedPermissionedToken.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IHooks} from "@uniswap/v4-core/src/interfaces/IHooks.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";
import "forge-std/console2.sol";

contract PermissionedV4RouterTest is PermissionedRoutingTestHelpers {
    address public alice = makeAddr("ALICE");
    Currency wrappedCurrency0;
    Currency wrappedCurrency1;
    function setUp() public {
        setupPermissionedRouterCurrenciesAndPoolsWithLiquidity(alice);
        wrappedCurrency0 = Currency.wrap(address(wrappedToken0));
        wrappedCurrency1 = Currency.wrap(address(wrappedToken1));
        plan = Planner.init();
        // Setup permissions and approvals
        setupPermissionsAndApprovals();
    }

    function setupPermissionsAndApprovals() internal {
        // Add addresses to allowlist
        mockAllowList.addToAllowList(alice);

        // Setup approvals for test contract
        _setupApprovals();

        // Setup approvals for authorized user
        vm.startPrank(alice);
        _setupApprovals();
        vm.stopPrank();
    }

    function _setupApprovals() internal {
        IERC20(Currency.unwrap(currency0)).approve(address(permit2), type(uint160).max);
        IERC20(Currency.unwrap(currency1)).approve(address(permit2), type(uint160).max);
        IERC20(Currency.unwrap(currency0)).approve(address(permissionedRouter), type(uint160).max);
        IERC20(Currency.unwrap(currency1)).approve(address(permissionedRouter), type(uint160).max);
        IERC20(Currency.unwrap(currency0)).approve(address(positionManager), type(uint160).max);
        IERC20(Currency.unwrap(currency1)).approve(address(positionManager), type(uint160).max);

        permit2.approve(Currency.unwrap(currency0), address(permissionedRouter), type(uint160).max, 2 ** 47);
        permit2.approve(Currency.unwrap(currency1), address(permissionedRouter), type(uint160).max, 2 ** 47);
        permit2.approve(Currency.unwrap(currency0), address(positionManager), type(uint160).max, 2 ** 47);
        permit2.approve(Currency.unwrap(currency1), address(positionManager), type(uint160).max, 2 ** 47);
    }

    function test_gas_bytecodeSize() public {
        vm.snapshotValue("PermissionedV4Router_Bytecode", address(permissionedRouter).code.length);
    }

    function test_router_initcodeHash() public {
        vm.snapshotValue(
            "permissioned router initcode hash (without constructor params, as uint256)",
            uint256(
                keccak256(
                    abi.encodePacked(
                        vm.getCode("src/hooks/permissionedPools/PermissionedV4Router.sol:PermissionedV4Router")
                    )
                )
            )
        );
    }

    /*//////////////////////////////////////////////////////////////
                        PERMISSIONED TOKEN SWAPS
    //////////////////////////////////////////////////////////////*/

    function test_gas_swapExactInputSingle_permissionedTokens() public {
        uint256 amountIn = 1000;
        PoolKey memory wrappedKey = PoolKey(wrappedCurrency1, wrappedCurrency0, 3000, 60, IHooks(address(permissionedRouter)));

        IV4Router.ExactInputSingleParams memory params =
            IV4Router.ExactInputSingleParams(wrappedKey, true, uint128(amountIn), 0, bytes(""));

        plan = plan.add(Actions.SWAP_EXACT_IN_SINGLE, abi.encode(params));
        bytes memory data = plan.finalizeSwap(wrappedCurrency1, wrappedCurrency0, ActionConstants.MSG_SENDER);

        permissionedRouter.execute(data);
        vm.snapshotGasLastCall("PermissionedV4Router_ExactInputSingle_PermissionedTokens");
    }

    function test_gas_swapExactIn_1Hop_permissionedTokens() public {
        uint256 amountIn = 1 ether;

        tokenPath.push(currency0);
        tokenPath.push(currency1);
        IV4Router.ExactInputParams memory params = _getExactInputParams(tokenPath, amountIn);

        plan = plan.add(Actions.SWAP_EXACT_IN, abi.encode(params));
        bytes memory data = plan.finalizeSwap(currency0, currency1, ActionConstants.MSG_SENDER);

        permissionedRouter.execute(data);
        vm.snapshotGasLastCall("PermissionedV4Router_ExactIn1Hop_PermissionedTokens");
    }

    function test_gas_swapExactOutputSingle_permissionedTokens() public {
        uint256 amountOut = 1 ether;

        PoolKey memory wrappedKey = PoolKey(currency0, currency1, 3000, 60, IHooks(address(0)));

        IV4Router.ExactOutputSingleParams memory params =
            IV4Router.ExactOutputSingleParams(wrappedKey, true, uint128(amountOut), type(uint128).max, bytes(""));

        plan = plan.add(Actions.SWAP_EXACT_OUT_SINGLE, abi.encode(params));
        bytes memory data = plan.finalizeSwap(currency0, currency1, ActionConstants.MSG_SENDER);

        permissionedRouter.execute(data);
        vm.snapshotGasLastCall("PermissionedV4Router_ExactOutputSingle_PermissionedTokens");
    }

    /*//////////////////////////////////////////////////////////////
                        MIXED TOKEN SWAPS (PERMISSIONED + REGULAR)
    //////////////////////////////////////////////////////////////*/

    function test_gas_swapExactInputSingle_mixedTokens() public {
        uint256 amountIn = 1 ether;

        PoolKey memory mixedKey = PoolKey(currency0, currency1, 3000, 60, IHooks(address(0)));

        IV4Router.ExactInputSingleParams memory params =
            IV4Router.ExactInputSingleParams(mixedKey, true, uint128(amountIn), 0, bytes(""));

        plan = plan.add(Actions.SWAP_EXACT_IN_SINGLE, abi.encode(params));
        bytes memory data = plan.finalizeSwap(currency0, currency1, ActionConstants.MSG_SENDER);

        permissionedRouter.execute(data);
        vm.snapshotGasLastCall("PermissionedV4Router_ExactInputSingle_MixedTokens");
    }

    /*//////////////////////////////////////////////////////////////
                        NATIVE TOKEN SWAPS
    //////////////////////////////////////////////////////////////*/

    function test_gas_nativeIn_swapExactInputSingle() public {
        uint256 amountIn = 1 ether;

        IV4Router.ExactInputSingleParams memory params =
            IV4Router.ExactInputSingleParams(nativeKey, true, uint128(amountIn), 0, bytes(""));

        plan = plan.add(Actions.SWAP_EXACT_IN_SINGLE, abi.encode(params));
        bytes memory data = plan.finalizeSwap(nativeKey.currency0, nativeKey.currency1, ActionConstants.MSG_SENDER);

        permissionedRouter.execute{value: amountIn}(data);
        vm.snapshotGasLastCall("PermissionedV4Router_ExactInputSingle_nativeIn");
    }

    function test_gas_nativeOut_swapExactInputSingle() public {
        uint256 amountIn = 1 ether;

        IV4Router.ExactInputSingleParams memory params =
            IV4Router.ExactInputSingleParams(nativeKey, false, uint128(amountIn), 0, bytes(""));

        plan = plan.add(Actions.SWAP_EXACT_IN_SINGLE, abi.encode(params));
        bytes memory data = plan.finalizeSwap(nativeKey.currency1, nativeKey.currency0, ActionConstants.MSG_SENDER);

        permissionedRouter.execute(data);
        vm.snapshotGasLastCall("PermissionedV4Router_ExactInputSingle_nativeOut");
    }

    /*//////////////////////////////////////////////////////////////
                        PERMISSION TESTS
    //////////////////////////////////////////////////////////////*/

    function test_swap_reverts_unauthorized_user() public {
        address unauthorizedUser = makeAddr("UNAUTHORIZED");
        IERC20(Currency.unwrap(currency0)).transfer(unauthorizedUser, 2 ether);
        IERC20(Currency.unwrap(currency1)).transfer(unauthorizedUser, 2 ether);
        uint256 amountIn = 1 ether;

        PoolKey memory wrappedKey = PoolKey(currency0, currency1, 3000, 60, IHooks(address(0)));

        IV4Router.ExactInputSingleParams memory params =
            IV4Router.ExactInputSingleParams(wrappedKey, true, uint128(amountIn), 0, bytes(""));

        plan = plan.add(Actions.SWAP_EXACT_IN_SINGLE, abi.encode(params));
        bytes memory data = plan.finalizeSwap(currency0, currency1, ActionConstants.MSG_SENDER);

        vm.prank(unauthorizedUser);
        vm.expectRevert();
        permissionedRouter.execute(data);
    }

    function test_swap_succeeds_authorized_user() public {
        IERC20(Currency.unwrap(currency0)).transfer(alice, 2 ether);
        IERC20(Currency.unwrap(currency1)).transfer(alice, 2 ether);

        uint256 amountIn = 1 ether;

        PoolKey memory wrappedKey = PoolKey(currency0, currency1, 3000, 60, IHooks(address(0)));

        IV4Router.ExactInputSingleParams memory params =
            IV4Router.ExactInputSingleParams(wrappedKey, true, uint128(amountIn), 0, bytes(""));

        plan = plan.add(Actions.SWAP_EXACT_IN_SINGLE, abi.encode(params));
        bytes memory data = plan.finalizeSwap(currency0, currency1, ActionConstants.MSG_SENDER);

        vm.prank(alice);
        permissionedRouter.execute(data);
    }
}
