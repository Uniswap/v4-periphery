// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {Deployers} from "@uniswap/v4-core/test/utils/Deployers.sol";
import {MockERC20} from "solmate/src/test/utils/mocks/MockERC20.sol";
import {Currency, CurrencyLibrary} from "@uniswap/v4-core/src/types/Currency.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";
import {PoolId} from "@uniswap/v4-core/src/types/PoolId.sol";
import {IHooks} from "@uniswap/v4-core/src/interfaces/IHooks.sol";
import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {TickMath} from "@uniswap/v4-core/src/libraries/TickMath.sol";
import {Constants} from "@uniswap/v4-core/test/utils/Constants.sol";
import {PoolModifyLiquidityTest} from "@uniswap/v4-core/src/test/PoolModifyLiquidityTest.sol";
import {ModifyLiquidityParams} from "@uniswap/v4-core/src/types/PoolOperation.sol";
import {StateLibrary} from "@uniswap/v4-core/src/libraries/StateLibrary.sol";
import {BalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";
import {LiquidityAmounts} from "@uniswap/v4-core/test/utils/LiquidityAmounts.sol";
import {IAllowlistChecker} from "src/hooks/permissionedPools/interfaces/IAllowlistChecker.sol";
import {WrappedPermissionedToken} from "src/hooks/permissionedPools/WrappedPermissionedToken.sol";
import {MockAllowList} from "../mocks/MockAllowList.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {WrappedPermissionedTokenFactory} from "src/hooks/permissionedPools/WrappedPermissionedTokenFactory.sol";
import {PermissionedPositionManager} from "src/hooks/permissionedPools/PermissionedPositionManager.sol";
import {console2} from "forge-std/console2.sol";


contract PermissionedPoolsTest is Test, Deployers {

    IAllowlistChecker public allowListChecker;
    MockAllowList public mockAllowList;
    // Test tokens
    MockERC20 public tokenA;
    MockERC20 public tokenB;
    WrappedPermissionedToken public wrappedTokenA;

    // Currencies for the pool
    Currency public currencyA;
    Currency public currencyB;

    // Pool configuration
    PoolKey public poolKey;
    PoolId public poolId;

    // Test constants
    uint24 public constant POOL_FEE = 3000; // 0.3%

    // Test addresses
    address public constant TEST_USER = address(0x1234);
    address public constant TEST_USER_2 = address(0x5678);

    // Liquidity parameters for testing
    int24 public constant TICK_LOWER = -120;
    int24 public constant TICK_UPPER = 120;
    uint128 public constant LIQUIDITY_AMOUNT = 1e8;

    function setUp() public {
        // Deploy fresh pool manager
        deployFreshManager();
        // Deploy mock allow list
        mockAllowList = new MockAllowList();
        mockAllowList.addToAllowList(TEST_USER);
        mockAllowList.addToAllowList(TEST_USER_2);
        mockAllowList.addToAllowList(address(this));
        allowListChecker = IAllowlistChecker(address(mockAllowList));

        // Deploy test tokens
        MockERC20 permissionedTokenA = new MockERC20("Token A", "TKA", 18);
        tokenB = new MockERC20("Token B", "TKB", 18);
       
        tokenA = MockERC20(address(permissionedTokenA));
        tokenA.mint(address(this), 1e18);
        WrappedPermissionedTokenFactory wrappedPermissionedTokenFactory = new WrappedPermissionedTokenFactory(address(manager));
        wrappedTokenA = WrappedPermissionedToken(wrappedPermissionedTokenFactory.createWrappedPermissionedToken(IERC20(address(permissionedTokenA)), address(this), allowListChecker));
        
        // Mint tokens to test contract
        tokenA.mint(address(this), 1000e18);
        tokenB.mint(address(this), 1000e18);

        // Mint tokens to test users
        tokenA.mint(TEST_USER, 100e18);
        tokenB.mint(TEST_USER, 100e18);
        tokenA.mint(TEST_USER_2, 100e18);
        tokenB.mint(TEST_USER_2, 100e18);

        // Wrap tokens as currencies
        currencyA = Currency.wrap(address(tokenA));
        currencyB = Currency.wrap(address(tokenB));

        // Sort currencies (required for pool creation)
        (currencyA, currencyB) = sortCurrencies(currencyA, currencyB);

        // Create pool key (no hooks for basic setup)
        poolKey = PoolKey({
            currency0: currencyA,
            currency1: currencyB,
            fee: POOL_FEE,
            tickSpacing: int24(POOL_FEE / 100 * 2), // Standard tick spacing
            hooks: IHooks(address(0)) // No hooks for basic setup
        });

        // Initialize the pool
        poolId = poolKey.toId();
        manager.initialize(poolKey, SQRT_PRICE_1_1);

        // Approve tokens for the pool manager
        tokenA.approve(address(manager), type(uint256).max);
        tokenB.approve(address(manager), type(uint256).max);
    }

    /**
     * @dev Helper function to sort currencies (required for pool creation)
     */
    function sortCurrencies(Currency currency0, Currency currency1) internal pure returns (Currency, Currency) {
        if (Currency.unwrap(currency0) < Currency.unwrap(currency1)) {
            return (currency0, currency1);
        } else {
            return (currency1, currency0);
        }
    }

    /**
     * @dev Helper function to get the correct token order based on sorted currencies
     */
    function getTokenOrder() internal view returns (MockERC20 token0, MockERC20 token1) {
        if (Currency.unwrap(currencyA) < Currency.unwrap(currencyB)) {
            return (tokenA, tokenB);
        } else {
            return (tokenB, tokenA);
        }
    }

    /**
     * @dev Helper function to add liquidity to the pool
     */
    function addLiquidity(
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidityDelta,
        uint256 amount0Desired,
        uint256 amount1Desired
    ) internal returns (int256 amount0, int256 amount1) {
        // Get the modify liquidity router
        PoolModifyLiquidityTest modifyLiquidityRouter = new PoolModifyLiquidityTest(manager);

        // Approve tokens for the router
        tokenA.approve(address(modifyLiquidityRouter), type(uint256).max);
        tokenB.approve(address(modifyLiquidityRouter), type(uint256).max);

        // Create liquidity parameters
        ModifyLiquidityParams memory params = ModifyLiquidityParams({
            tickLower: tickLower,
            tickUpper: tickUpper,
            liquidityDelta: int256(uint256(liquidityDelta)),
            salt: 0
        });

        // Add liquidity
        BalanceDelta delta = modifyLiquidityRouter.modifyLiquidity(poolKey, params, "");

        amount0 = int256(delta.amount0());
        amount1 = int256(delta.amount1());
    }

    /**
     * @dev Basic test to verify the setup works
     */
    function test_setup_basic() public view {
        // Verify tokens were deployed
        assertEq(tokenA.name(), "Token A");
        assertEq(tokenA.symbol(), "TKA");
        assertEq(tokenA.decimals(), 18);

        assertEq(tokenB.name(), "Token B");
        assertEq(tokenB.symbol(), "TKB");
        assertEq(tokenB.decimals(), 18);

        // Verify pool was created
        (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee) = StateLibrary.getSlot0(manager, poolId);
        assertTrue(sqrtPriceX96 > 0, "Pool should be initialized");
        assertEq(tick, 0, "Pool should start at tick 0");

        // Verify currencies are sorted
        assertTrue(Currency.unwrap(currencyA) < Currency.unwrap(currencyB), "Currencies should be sorted");
    }

    /**
     * @dev Test that we can add liquidity to the pool
     */
    function test_fuzz_add_liquidity(int24 tickLower, int24 tickUpper, uint128 liquidityAmount) public {
        // Bound the inputs to valid ranges
        tickLower = int24(bound(tickLower, -240, 0)); // Valid tick range, ensure lower <= 0
        tickUpper = int24(bound(tickUpper, 0, 240)); // Valid tick range, ensure upper >= 0
        vm.assume(tickLower < tickUpper); // Ensure lower < upper
        
        // Align ticks with pool's tick spacing (60 for 3000 fee)
        int24 tickSpacing = int24(POOL_FEE / 100 * 2); // 60
        tickLower = (tickLower / tickSpacing) * tickSpacing; // Round down to nearest valid tick
        tickUpper = (tickUpper / tickSpacing) * tickSpacing; // Round down to nearest valid tick
        
        // Ensure we still have a valid range after alignment
        vm.assume(tickLower < tickUpper);
        
        // Bound liquidity amount to reasonable range
        liquidityAmount = uint128(bound(liquidityAmount, 1e6, 1e8)); // 1e6 to 1e8 liquidity
        
        (uint160 sqrtPriceX96,,,) = StateLibrary.getSlot0(manager, poolKey.toId());

        (uint256 amount0, uint256 amount1) = LiquidityAmounts.getAmountsForLiquidity(
            sqrtPriceX96,
            TickMath.getSqrtPriceAtTick(tickLower),
            TickMath.getSqrtPriceAtTick(tickUpper),
            liquidityAmount
        );
        
        (int256 actualAmount0, int256 actualAmount1) =
            addLiquidity(tickLower, tickUpper, liquidityAmount, amount0, amount1);

        // Verify liquidity was added (basic check)
        assertEq(actualAmount0, amount0 == 0 ? int256(0) : -int256(amount0)-1, "Added liquidity amounts for token 0 should match");
        assertEq(actualAmount1, amount1 == 0 ? int256(0) : -int256(amount1)-1, "Added liquidity amounts for token 1 should match");
    }

    /**
     * @dev Test that we can get pool information
     */
    function test_pool_info() public view {
        // Get pool slot0 data
        (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee) = StateLibrary.getSlot0(manager, poolId);

        // Verify pool state
        assertTrue(sqrtPriceX96 > 0, "Pool should have a valid sqrt price");
        assertEq(tick, 0, "Pool should start at tick 0");
        assertEq(lpFee, POOL_FEE, "Pool should have correct fee");
        assertEq(protocolFee, 0, "Protocol fee should be 0 by default");

        // Verify pool key
        assertEq(Currency.unwrap(poolKey.currency0), Currency.unwrap(currencyA), "Pool key currency0 should match");
        assertEq(Currency.unwrap(poolKey.currency1), Currency.unwrap(currencyB), "Pool key currency1 should match");
        assertEq(poolKey.fee, POOL_FEE, "Pool key fee should match");
        assertEq(address(poolKey.hooks), address(0), "Pool key hooks should be zero address");
    }
}
